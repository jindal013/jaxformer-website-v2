<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Jaxformer: Scaling Modern Transformers </title> <meta name="author" content=" "> <meta name="description" content="This is a zero-to-one guide on scaling modern transformers with n-dimensional parallelism. Transformers have driven much of the deep learning revolution, yet no practical guide reflects SOTA architectures and the complexities of large-scale language modelling. While excellent resources such as DeepMind’s 'How to Scale Your Model' and HuggingFace’s 'Ultra Scale Playbook' exist, a gap remains between theory and end-to-end implementation. We aim to bridge that gap by showing you how to scale a model from scratch (in Jax, with code!) to current standards."> <meta name="keywords" content="jscaling, jax, llms, transformers, tpus, google, cloud, parallelism, distributed"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/jaxformer-icon.png?7001ddef15419e25335b33b49c6ce725"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jaxformer.com/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Jaxformer",
            "description": "This is a zero-to-one guide on scaling modern transformers with n-dimensional parallelism. Transformers have driven much of the deep learning revolution, yet no practical guide reflects SOTA architectures and the complexities of large-scale language modelling. While excellent resources such as DeepMind’s 'How to Scale Your Model' and HuggingFace’s 'Ultra Scale Playbook' exist, a gap remains between theory and end-to-end implementation. We aim to bridge that gap by showing you how to scale a model from scratch (in Jax, with code!) to current standards.",
            "published": "September 05, 2025",
            "authors": [
              
              {
                "author": "Aditya Makkar",
                "authorURL": "https://x.com/AdityaMakkar000"
              },
              
              {
                "author": "Divya Makkar",
                "authorURL": "https://x.com/_DivyaMakkar"
              },
              
              {
                "author": "Chinmay Jindal",
                "authorURL": "https://x.com/chinmayjindal_"
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <script>
    function goToTop() {
      document.body.scrollTop = 0; // For Safari
      document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    }

    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function() {scrollFunction()};

    function scrollFunction() {
      // Get the button:
      let mybutton = document.getElementById("top-button");

      if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
        mybutton.style.display = "block";
      } else {
        mybutton.style.display = "none";
      }
  }
  </script> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Jaxformer: Scaling Modern Transformers </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="left-button section-button"><a href=""><svg viewbox="-78.5 0 512 512"><path d="M257 64L291 98 128 262 291 426 257 460 61 262 257 64Z"></path></svg></a></div> <div class="right-button section-button"><a href="../tokenization"><svg viewbox="-78.5 0 512 512"><path d="M98 460L64 426 227 262 64 98 98 64 294 262 98 460Z"></path></svg></a></div> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item nav-hidden"><a class="nav-link" onclick="goToTop()" id="top-button" style="display: none;">Back to Top</a></li> <li class="nav-item nav-hidden"><p class="nav-link"></p></li> <li class="nav-item nav-hidden"><a class="nav-link" href="">Previous Part</a></li> <li class="nav-item nav-hidden"><a class="nav-link" href="../tokenization">Next Part</a></li> <li class="nav-item nav-hidden"><p class="nav-link"></p></li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Sections </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/">Part 0. Introduction</a> <a class="dropdown-item " href="/tokenization/">Part 1. Tokenization</a> <a class="dropdown-item " href="/base_model/">Part 2. Base Model</a> <a class="dropdown-item " href="/sharded/">Part 3. Sharded Model</a> <a class="dropdown-item " href="/dataset/">Part 4. Dataset &amp; Config</a> <a class="dropdown-item " href="/distributed_training/">Part 5. Distributed Training</a> <a class="dropdown-item " href="/moe/">Part 6. Mixture of Experts</a> <a class="dropdown-item " href="/training/">Part 7. Training Results</a> <a class="dropdown-item " href="/conclusion/">Part 8. Conclusion</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Jaxformer</h1> <p><span class="subtitle">Scaling Modern Transformers</span> <span class="subtitle-links">(Part 0: Intro | <a href="../tokenization">Part 1: Tokenization</a>)</span></p> <p>This is a zero-to-one guide on scaling modern transformers with n-dimensional parallelism. Transformers have driven much of the deep learning revolution, yet no practical guide reflects SOTA architectures and the complexities of large-scale language modelling. While excellent resources such as DeepMind’s 'How to Scale Your Model' and HuggingFace’s 'Ultra Scale Playbook' exist, a gap remains between theory and end-to-end implementation. We aim to bridge that gap by showing you how to scale a model from scratch (in Jax, with code!) to current standards.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#high-level-outline">High-Level Outline</a> </div> <div> <a href="#links-to-sections">Links to Sections</a> </div> </nav> </d-contents> <p><img id="banner" class="img-fluid" alt="Banner" src="/assets/img/banner-light.png" data-light-src="/assets/img/banner.png" data-dark-src="/assets/img/banner-light.png"></p> <script>
  document.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('light-toggle');
    const banner = document.getElementById('banner');

    function swapBanner() {
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      banner.src = isDark ? banner.dataset.darkSrc : banner.dataset.lightSrc;
    }

    swapBanner();

    btn.addEventListener('click', () => requestAnimationFrame(swapBanner));
  });
</script> <p>Much of deep learning still boils down to a kind of black magic, but optimizing the performance of your models doesn’t have to — even at huge scale! Relatively simple principles apply everywhere — from dealing with a single accelerator to tens of thousands — and understanding them lets you do many useful things:</p> <ul> <li>Ballpark how close parts of your model are to their theoretical optimum.</li> <li>Make informed choices about different parallelism schemes at different scales (how you split the computation across multiple devices).</li> <li>Estimate the cost and time required to train and run large Transformer models.</li> <li>Design algorithms that take advantage of <a href="https://arxiv.org/abs/2205.14135" rel="external nofollow noopener" target="_blank">specific</a> <a href="https://arxiv.org/abs/1911.02150" rel="external nofollow noopener" target="_blank">hardware</a> <a href="https://arxiv.org/abs/2007.00072" rel="external nofollow noopener" target="_blank">affordances</a>.</li> <li>Design hardware driven by an explicit understanding of what limits current algorithm performance.</li> </ul> <p><strong>Expected background:</strong> We’re going to assume you have a basic understanding of LLMs and the Transformer architecture but not necessarily how they operate at scale. You should know the basics of LLM training and ideally have some basic familiarity with JAX. Some useful background reading might include <a href="https://jalammar.github.io/illustrated-transformer/" rel="external nofollow noopener" target="_blank">this blog post</a> on the Transformer architecture and <a href="https://arxiv.org/abs/1706.03762" rel="external nofollow noopener" target="_blank">the original Transformer paper</a>. Also check <a href="conclusion#further-reading">this list</a> out for more useful concurrent and future reading.</p> <p><strong>Goals &amp; Feedback:</strong> By the end, you should feel comfortable estimating the best parallelism scheme for a Transformer model on a given hardware platform, and roughly how long training and inference should take. If you don’t, email us or leave a comment! We’d love to know how we could make this clearer.</p> <p class="announce">You might also enjoy reading the new <a href="gpus">Section 12</a> on NVIDIA GPUs!</p> <h3 id="why-should-you-care">Why should you care?</h3> <p>Three or four years ago, I don’t think most ML researchers would have needed to understand any of the content in this book. But today even “small” models run so close to hardware limits that doing novel research requires you to think about efficiency at scale.<d-footnote>Historically, ML research has followed something of a tick-tock cycle between systems innovations and software improvements. Alex Krizhevsky had to write unholy CUDA code to make CNNs fast but within a couple years, libraries like Theano and TensorFlow meant you didn't have to. Maybe that will happen here too and everything in this book will be abstracted away in a few years. But scaling laws have pushed our models perpetually to the very frontier of our hardware, and it seems likely that, in the near future, doing cutting edge research will be inextricably tied to an understanding of how to efficiently scale models to large hardware topologies.</d-footnote> <strong>A 20% win on benchmarks is irrelevant if it comes at a 20% cost to roofline efficiency.</strong> Promising model architectures routinely fail either because they <em>can’t</em> run efficiently at scale or because no one puts in the work to make them do so.</p> <p><strong>The goal of “model scaling” is to be able to increase the number of chips used for training or inference while achieving a proportional, linear increase in throughput.</strong> This is known as “<em>strong scaling</em>”. Although adding additional chips (“parallelism”) usually decreases the computation time, it also comes at the cost of added communication between chips. When communication takes longer than computation we become “communication bound” and cannot scale strongly.<d-footnote>As your computation time decreases, you also typically face bottlenecks at the level of a single chip. Your shiny new TPU or GPU may be rated to perform 500 trillion operations-per-second, but if you aren't careful it can just as easily do a tenth of that if it's bogged down moving parameters around in memory. The interplay of per-chip computation, memory bandwidth, and total memory is critical to the scaling story.</d-footnote> If we understand our hardware well enough to anticipate where these bottlenecks will arise, we can design or reconfigure our models to avoid them.<d-footnote>Hardware designers face the inverse problem: building hardware that provides just enough compute, bandwidth, and memory for our algorithms while minimizing cost. You can imagine how stressful this "co-design" problem is: you have to bet on what algorithms will look like when the first chips actually become available, often 2 to 3 years down the road. The story of the TPU is a resounding success in this game. Matrix multiplication is a unique algorithm in the sense that it uses far more FLOPs per byte of memory than almost any other (N FLOPs per byte), and early TPUs and their systolic array architecture achieved far better perf / $ than GPUs did at the time they were built. TPUs were designed for ML workloads, and GPUs with their TensorCores are rapidly changing to fill this niche as well. But you can imagine how costly it would have been if neural networks had not taken off, or had changed in some fundamental way that TPUs (which are inherently less flexible than GPUs) could not handle.</d-footnote></p> <p><em>Our goal in this book is to explain how TPU (and GPU) hardware works and how the Transformer architecture has evolved to perform well on current hardware. We hope this will be useful both for researchers designing new architectures and for engineers working to make the current generation of LLMs run fast.</em></p> <h2 id="high-level-outline">High-Level Outline</h2> <p>The overall structure of this book is as follows:</p> <p><a href="roofline">Section 1</a> explains roofline analysis and what factors can limit our ability to scale (communication, computation, and memory). <a href="tpus">Section 2</a> and <a href="sharding">Section 3</a> talk in detail about how TPUs work, both as individual chips and — of critical importance — as an interconnected system with inter-chip links of limited bandwidth and latency. We’ll answer questions like:</p> <ul> <li>How long should a matrix multiply of a certain size take? At what point is it bound by compute or by memory or communication bandwidth?</li> <li>How are TPUs wired together to form training clusters? How much bandwidth does each part of the system have?</li> <li>How long does it take to gather, scatter, or re-distribute arrays across multiple TPUs?</li> <li>How do we efficiently multiply matrices that are distributed differently across devices?</li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/pointwise-product-480.webp 480w,/assets/img/pointwise-product-800.webp 800w,/assets/img/pointwise-product-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/pointwise-product.gif" class="img-small" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"><b>Figure:</b> a diagram from <a href="tpus">Section 2</a> showing how a TPU performs an elementwise product. Depending on the size of our arrays and the bandwidth of various links, we can find ourselves compute-bound (using the full hardware compute capacity) or comms-bound (bottlenecked by memory loading).</figcaption> </figure> <p>Five years ago ML had a colorful landscape of architectures — ConvNets, LSTMs, MLPs, Transformers — but now we mostly just have the Transformer<d-cite key="transformers"></d-cite>. We strongly believe it’s worth understanding every piece of the Transformer architecture: the exact sizes of every matrix, where normalization occurs, how many parameters and FLOPs<d-footnote>FLoating point OPs, basically the total number of adds and multiplies required. While many sources take FLOPs to mean "operations per second", we use FLOPs/s to indicate that explicitly.</d-footnote> are in each part. <a href="transformers">Section 4</a> goes through this “Transformer math” carefully, showing how to count the parameters and FLOPs for both training and inference. This tells us how much memory our model will use, how much time we’ll spend on compute or comms, and when attention will become important relative to the feed-forward blocks.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/transformer-diagram-480.webp 480w,/assets/img/transformer-diagram-800.webp 800w,/assets/img/transformer-diagram-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/transformer-diagram.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"><b>Figure:</b> a standard Transformer layer with each matrix multiplication (matmul) shown as a dot inside a circle. All parameters (excluding norms) are shown in purple. <a href="transformers">Section 4</a> walks through this diagram in more detail.</figcaption> </figure> <p><a href="training">Section 5: Training</a> and <a href="inference">Section 7: Inference</a> are the core of this essay, where we discuss the fundamental question: given a model of some size and some number of chips, how do I parallelize my model to stay in the “strong scaling” regime? This is a simple question with a surprisingly complicated answer. At a high level, there are 4 primary parallelism techniques used to split models over multiple chips (<strong>data</strong>, <strong>tensor</strong>, <strong>pipeline</strong> and <strong>expert</strong>), and a number of other techniques to reduce the memory requirements (<strong>rematerialisation</strong>, <strong>optimizer/model sharding (aka ZeRO)</strong>, <strong>host offload</strong>, <strong>gradient accumulation</strong>). We discuss many of these here.</p> <p>We hope by the end of these sections you should be able to choose among them yourself for new architectures or settings. <a href="applied-training">Section 6</a> and <a href="applied-inference">Section 8</a> are practical tutorials that apply these concepts to LLaMA-3, a popular open-source model.</p> <p>Finally, <a href="profiling">Section 9</a> and <a href="jax-stuff">Section 10</a> look at how to implement some of these ideas in JAX and how to profile and debug your code when things go wrong. <a href="gpus">Section 12</a> is a new section that dives into GPUs as well.</p> <p>Throughout we try to give you problems to work for yourself. Please feel no pressure to read all the sections or read them in order. And please leave feedback. For the time being, this is a draft and will continue to be revised. Thank you!</p> <p><em>We’d like to acknowledge James Bradbury and Blake Hechtman who derived many of the ideas in this doc.</em></p> <h3 class="next-section">Without further ado, <a href="roofline">here is Section 1</a> about TPU rooflines.</h3> <h2 id="links-to-sections">Links to Sections</h2> <p><em>This series is probably longer than it needs to be, but we hope that won’t deter you. The first three chapters are preliminaries and can be skipped if familiar, although they introduce notation used later. The final three parts might be the most practically useful, since they explain how to work with real models.</em></p> <p><strong>Part 1: Preliminaries</strong></p> <ul> <li> <p><a href="roofline"><strong>Chapter 1: A Brief Intro to Roofline Analysis</strong></a>. Algorithms are bounded by three things: compute, communication, and memory. We can use these to approximate how fast our algorithms will run.</p> </li> <li> <p><a href="tpus"><strong>Chapter 2: How to Think About TPUs</strong></a>. How do TPUs work? How does that affect what models we can train and serve?</p> </li> <li> <p><a href="sharding"><strong>Chapter 3: Sharded Matrices and How to Multiply Them</strong></a>. Here we explain model sharding and multi-TPU parallelism by way of our favorite operation: (sharded) matrix multiplications.</p> </li> </ul> <p><strong>Part 2: Transformers</strong></p> <ul> <li> <p><a href="transformers"><strong>Chapter 4: All the Transformer Math You Need to Know</strong></a>. How many FLOPs does a Transformer use in its forward and backwards pass? Can you calculate the number of parameters? The size of its KV caches? We work through this math here.</p> </li> <li> <p><a href="training"><strong>Chapter 5: How to Parallelize a Transformer for Training</strong></a>. FSDP. Megatron sharding. Pipeline parallelism. Given some number of chips, how do I train a model of a given size with a given batch size as efficiently as possible?</p> </li> <li> <p><a href="applied-training"><strong>Chapter 6: Training LLaMA 3 on TPUs</strong></a>. How would we train LLaMA 3 on TPUs? How long would it take? How much would it cost?</p> </li> <li> <p><a href="inference"><strong>Chapter 7: All About Transformer Inference</strong></a>. Once we’ve trained a model, we have to serve it. Inference adds a new consideration — latency — and changes up the memory landscape. We’ll talk about how disaggregated serving works and how to think about KV caches.</p> </li> <li> <p><a href="applied-inference"><strong>Chapter 8: Serving LLaMA 3 on TPUs</strong></a>. How much would it cost to serve LLaMA 3 on TPU v5e? What are the latency/throughput tradeoffs?</p> </li> </ul> <p><strong>Part 3: Practical Tutorials</strong></p> <ul> <li> <p><a href="profiling"><strong>Chapter 9: How to Profile TPU Code</strong></a>. Real LLMs are never as simple as the theory above. Here we explain the JAX + XLA stack and how to use the JAX/TensorBoard profiler to debug and fix real issues.</p> </li> <li> <p><a href="jax-stuff"><strong>Chapter 10: Programming TPUs in JAX</strong></a>. JAX provides a bunch of magical APIs for parallelizing computation, but you need to know how to use them. Fun examples and worked problems.</p> </li> </ul> <p><strong>Part 4: Conclusions and Bonus Content</strong></p> <ul> <li> <p><a href="conclusion"><strong>Chapter 11: Conclusions and Further Reading</strong></a>. Closing thoughts and further reading on TPUs and LLMs.</p> </li> <li> <p><a href="gpus"><strong>Chapter 12: How to Think About GPUs</strong></a>. A bonus section about GPUs, how they work, how they’re networked, and how their rooflines differ from TPUs.</p> </li> </ul> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/main.bib"></d-bibliography> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'jindal013/jaxformer-website-v2',
        'data-repo-id': 'R_kgDOPoEVEA',
        'data-category': 'General',
        'data-category-id': 'DIC_kwDOPoEVEM4Cu2n4',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-loading': '1',
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 . Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> </body> </html>